# üìã TODO LIST - ICONIC LOGISTICS CMS
**Ng√†y t·∫°o:** 05/11/2025
**Code Review Session:** claude/code-review-session-011CUpQnrz8nKe4PXCBLzEEc

---

## üìä T·ªîNG QUAN

D·ª± √°n c√≥ **ki·∫øn tr√∫c t·ªët** v√† code **clean**, nh∆∞ng c·∫ßn kh·∫Øc ph·ª•c c√°c v·∫•n ƒë·ªÅ v·ªÅ:
- ‚ùå **Testing Coverage:** 0% (ch∆∞a c√≥ test n√†o)
- ‚ö†Ô∏è **Security Hardening:** C√≤n nhi·ªÅu gaps
- ‚ö†Ô∏è **Input Validation:** Thi·∫øu validation chi ti·∫øt
- ‚ö†Ô∏è **Error Handling:** Verbose errors leak info
- ‚ÑπÔ∏è **Optimization:** Thi·∫øu caching, pagination m·ªôt s·ªë API

**Rating hi·ªán t·∫°i:** 7/10
**Target sau improvements:** 9/10

---

## üî¥ CRITICAL PRIORITY (Tr∆∞·ªõc khi Production - 2-3 tu·∫ßn)

### ‚úÖ TASK 1: Fix JWT_SECRET Validation
**M·ª©c ƒë·ªô:** üî¥ CRITICAL
**File:** `src/lib/auth.ts:6`
**∆Ø·ªõc t√≠nh:** 15 ph√∫t

**V·∫•n ƒë·ªÅ hi·ªán t·∫°i:**
```typescript
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'
```
- N·∫øu qu√™n set JWT_SECRET, s·∫Ω d√πng default value
- Attacker c√≥ th·ªÉ fake token v·ªõi secret key m·∫∑c ƒë·ªãnh

**C·∫ßn l√†m:**
```typescript
const JWT_SECRET = process.env.JWT_SECRET
if (!JWT_SECRET || JWT_SECRET.length < 32) {
  throw new Error('JWT_SECRET must be set and at least 32 characters')
}
```

**Checklist:**
- [ ] Update `src/lib/auth.ts`
- [ ] Update `src/lib/auth-edge.ts`
- [ ] Add validation trong startup
- [ ] Update `.env.example` v·ªõi comment v·ªÅ y√™u c·∫ßu
- [ ] Test v·ªõi missing JWT_SECRET
- [ ] Test v·ªõi weak JWT_SECRET (<32 chars)

---

### ‚úÖ TASK 2: Add Rate Limiting cho Login
**M·ª©c ƒë·ªô:** üî¥ CRITICAL
**File:** `src/app/api/auth/login/route.ts`
**∆Ø·ªõc t√≠nh:** 2-3 gi·ªù

**V·∫•n ƒë·ªÅ:**
- Kh√¥ng c√≥ throttling ‚Üí d·ªÖ b·ªã brute force
- Attacker c√≥ th·ªÉ th·ª≠ h√†ng tri·ªáu password

**C·∫ßn l√†m:**
1. C√†i package: `npm install @upstash/ratelimit @upstash/redis`
2. Ho·∫∑c d√πng in-memory solution: `npm install express-rate-limit`
3. Implement rate limiting:
   - Max 5 attempts / 15 ph√∫t per IP
   - Max 3 attempts / 15 ph√∫t per email
   - Exponential backoff
4. Add CAPTCHA sau 3 l·∫ßn th·∫•t b·∫°i (optional)

**Code m·∫´u:**
```typescript
import rateLimit from 'express-rate-limit'

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many login attempts, please try again later',
})

// Ho·∫∑c d√πng Next.js middleware v·ªõi Redis
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(5, '15 m'),
})
```

**Checklist:**
- [ ] Ch·ªçn rate limiting solution (Upstash ho·∫∑c in-memory)
- [ ] Setup Redis n·∫øu d√πng Upstash
- [ ] Implement rate limiter
- [ ] Add per-IP limiting
- [ ] Add per-email limiting
- [ ] Log failed attempts
- [ ] Add error message cho user
- [ ] Test v·ªõi nhi·ªÅu failed attempts
- [ ] Update documentation

---

### ‚úÖ TASK 3: Move Hardcoded URLs sang Environment Variables
**M·ª©c ƒë·ªô:** üî¥ CRITICAL
**Files:** Multiple files
**∆Ø·ªõc t√≠nh:** 30 ph√∫t

**V·∫•n ƒë·ªÅ:**
```typescript
// src/app/api/ai/generate-content/route.ts:4
const N8N_WEBHOOK_URL = 'https://n8n.iconiclogs.com/webhook/content'

// src/lib/adapters/shipmentlink.ts:4
const TRACKING_URL = 'https://ct.shipmentlink.com/servlet/TDB1_CargoTracking.do'
```

**C·∫ßn l√†m:**
1. Move URLs sang `.env`:
```env
N8N_WEBHOOK_URL=https://n8n.iconiclogs.com/webhook/content
N8N_API_KEY=your-secret-key-here
SHIPMENTLINK_API_URL=https://ct.shipmentlink.com/servlet/TDB1_CargoTracking.do
```

2. Update code:
```typescript
const N8N_WEBHOOK_URL = process.env.N8N_WEBHOOK_URL
const N8N_API_KEY = process.env.N8N_API_KEY

if (!N8N_WEBHOOK_URL) {
  throw new Error('N8N_WEBHOOK_URL is not configured')
}

// Add authentication header
headers: {
  'Content-Type': 'application/json',
  'Authorization': `Bearer ${N8N_API_KEY}`,
}
```

**Checklist:**
- [ ] Add env vars v√†o `.env.example`
- [ ] Update `src/app/api/ai/generate-content/route.ts`
- [ ] Update `src/lib/adapters/shipmentlink.ts`
- [ ] Add validation cho env vars
- [ ] Add authentication cho n8n webhook
- [ ] Update documentation
- [ ] Test v·ªõi different environments

---

### ‚úÖ TASK 4: Generic Error Messages trong Production
**M·ª©c ƒë·ªô:** üî¥ CRITICAL
**Files:** All API routes
**∆Ø·ªõc t√≠nh:** 1-2 gi·ªù

**V·∫•n ƒë·ªÅ:**
```typescript
// src/app/api/ai/generate-content/route.ts:52-55
return NextResponse.json(
  { error: 'Failed to generate content', details: String(error) },
  { status: 500 }
)
```
- Leak stack trace, file paths, versions
- Information disclosure vulnerability

**C·∫ßn l√†m:**
1. T·∫°o error handler utility:
```typescript
// src/lib/error-handler.ts
export function handleApiError(error: unknown, context: string) {
  console.error(`[${context}] Error:`, error)

  if (process.env.NODE_ENV === 'production') {
    return {
      error: 'An error occurred. Please try again later.',
      code: 'INTERNAL_ERROR'
    }
  }

  return {
    error: 'An error occurred',
    details: String(error),
    code: 'INTERNAL_ERROR'
  }
}
```

2. Update t·∫•t c·∫£ API routes ƒë·ªÉ d√πng generic errors

**Checklist:**
- [ ] T·∫°o `src/lib/error-handler.ts`
- [ ] Update t·∫•t c·∫£ API routes (15 files)
- [ ] Remove error details trong production
- [ ] Keep detailed logs ·ªü server side
- [ ] Add error codes cho t·ª´ng lo·∫°i error
- [ ] Setup error monitoring (Sentry optional)
- [ ] Test error responses trong production mode

**Files c·∫ßn update:**
- `src/app/api/auth/login/route.ts`
- `src/app/api/admin/posts/route.ts`
- `src/app/api/admin/posts/[id]/route.ts`
- `src/app/api/admin/users/route.ts`
- `src/app/api/admin/users/[id]/route.ts`
- `src/app/api/ai/generate-content/route.ts`
- `src/app/api/media/upload/route.ts`
- `src/app/api/contact/route.ts`
- `src/app/api/tracking/shipmentlink/route.ts`

---

### ‚úÖ TASK 5: Add Zod Validation cho API Routes
**M·ª©c ƒë·ªô:** üî¥ CRITICAL
**Files:** All API routes
**∆Ø·ªõc t√≠nh:** 3-4 gi·ªù

**V·∫•n ƒë·ªÅ:**
- Validation qu√° ƒë∆°n gi·∫£n (ch·ªâ check truthy)
- Kh√¥ng validate format (email, password length, etc.)
- Kh√¥ng sanitize input

**C·∫ßn l√†m:**
1. T·∫°o Zod schemas:
```typescript
// src/lib/validators.ts
import { z } from 'zod'

export const LoginSchema = z.object({
  email: z.string().email('Email kh√¥ng h·ª£p l·ªá'),
  password: z.string().min(8, 'M·∫≠t kh·∫©u t·ªëi thi·ªÉu 8 k√Ω t·ª±')
})

export const CreateUserSchema = z.object({
  email: z.string().email('Email kh√¥ng h·ª£p l·ªá'),
  name: z.string().min(2, 'T√™n t·ªëi thi·ªÉu 2 k√Ω t·ª±').optional(),
  password: z.string()
    .min(8, 'M·∫≠t kh·∫©u t·ªëi thi·ªÉu 8 k√Ω t·ª±')
    .regex(/[A-Z]/, 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 1 ch·ªØ hoa')
    .regex(/[0-9]/, 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 1 s·ªë'),
  role: z.enum(['SUPER_ADMIN', 'ADMIN', 'EDITOR', 'VIEWER'])
})

export const CreatePostSchema = z.object({
  title: z.string().min(5, 'Ti√™u ƒë·ªÅ t·ªëi thi·ªÉu 5 k√Ω t·ª±').max(200),
  slug: z.string().regex(/^[a-z0-9-]+$/, 'Slug ch·ªâ ch·ª©a ch·ªØ th∆∞·ªùng, s·ªë v√† d·∫•u g·∫°ch ngang'),
  summary: z.string().max(500).optional(),
  coverImageUrl: z.string().url().optional().or(z.literal('')),
  contentMd: z.string().min(10, 'N·ªôi dung t·ªëi thi·ªÉu 10 k√Ω t·ª±'),
  status: z.enum(['DRAFT', 'PUBLISHED'])
})

export const ContactFormSchema = z.object({
  name: z.string().min(2, 'T√™n t·ªëi thi·ªÉu 2 k√Ω t·ª±'),
  email: z.string().email('Email kh√¥ng h·ª£p l·ªá'),
  phone: z.string().regex(/^[0-9+\-\s()]+$/, 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá').optional(),
  company: z.string().max(200).optional(),
  message: z.string().min(10, 'Tin nh·∫Øn t·ªëi thi·ªÉu 10 k√Ω t·ª±').max(5000)
})

export const TrackingSchema = z.object({
  type: z.enum(['BOL', 'BOOKING'], {
    errorMap: () => ({ message: 'Type ph·∫£i l√† BOL ho·∫∑c BOOKING' })
  }),
  code: z.string().min(5, 'M√£ tracking t·ªëi thi·ªÉu 5 k√Ω t·ª±').max(50)
})
```

2. S·ª≠ d·ª•ng trong routes:
```typescript
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // Validate v·ªõi Zod
    const validated = LoginSchema.parse(body)

    // D√πng validated data thay v√¨ body
    const { email, password } = validated

    // ... rest of code
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', issues: error.issues },
        { status: 400 }
      )
    }
    // ... handle other errors
  }
}
```

**Checklist:**
- [ ] T·∫°o `src/lib/validators.ts`
- [ ] Define schemas cho t·∫•t c·∫£ endpoints
- [ ] Update `/api/auth/login` v·ªõi LoginSchema
- [ ] Update `/api/admin/users` v·ªõi CreateUserSchema
- [ ] Update `/api/admin/posts` v·ªõi CreatePostSchema
- [ ] Update `/api/contact` v·ªõi ContactFormSchema
- [ ] Update `/api/tracking/shipmentlink` v·ªõi TrackingSchema
- [ ] Add password strength requirements
- [ ] Add email format validation
- [ ] Test validation errors
- [ ] Update frontend ƒë·ªÉ hi·ªÉn th·ªã validation errors

---

### ‚úÖ TASK 6: Setup Basic Testing Framework
**M·ª©c ƒë·ªô:** üî¥ CRITICAL
**Files:** New test files
**∆Ø·ªõc t√≠nh:** 1-2 ng√†y

**V·∫•n ƒë·ªÅ:**
- 0% test coverage
- Kh√¥ng c√≥ Jest, Vitest, Playwright
- D·ªÖ b·ªã regression bugs

**C·∫ßn l√†m:**

#### Phase 1: Setup Jest cho Unit Tests (4 gi·ªù)
```bash
npm install -D jest @types/jest ts-jest @testing-library/react @testing-library/jest-dom
```

**jest.config.js:**
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.test.ts', '**/*.test.ts'],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
}
```

**Test v√≠ d·ª•:**
```typescript
// src/lib/__tests__/auth.test.ts
import { hashPassword, verifyPassword, generateToken, verifyToken } from '../auth'

describe('Auth utilities', () => {
  describe('Password hashing', () => {
    it('should hash password correctly', async () => {
      const password = 'testPassword123'
      const hash = await hashPassword(password)
      expect(hash).not.toBe(password)
      expect(hash).toHaveLength(60) // bcrypt hash length
    })

    it('should verify correct password', async () => {
      const password = 'testPassword123'
      const hash = await hashPassword(password)
      const isValid = await verifyPassword(password, hash)
      expect(isValid).toBe(true)
    })

    it('should reject incorrect password', async () => {
      const hash = await hashPassword('correct')
      const isValid = await verifyPassword('wrong', hash)
      expect(isValid).toBe(false)
    })
  })

  describe('JWT token', () => {
    it('should generate valid token', () => {
      const payload = { userId: '123', email: 'test@example.com', role: 'ADMIN' }
      const token = generateToken(payload)
      expect(token).toBeTruthy()
      expect(typeof token).toBe('string')
    })

    it('should verify valid token', () => {
      const payload = { userId: '123', email: 'test@example.com', role: 'ADMIN' }
      const token = generateToken(payload)
      const verified = verifyToken(token)
      expect(verified).toMatchObject(payload)
    })

    it('should reject invalid token', () => {
      const verified = verifyToken('invalid-token')
      expect(verified).toBeNull()
    })
  })
})
```

#### Phase 2: Setup Playwright cho E2E Tests (4 gi·ªù)
```bash
npm install -D @playwright/test
npx playwright install
```

**playwright.config.ts:**
```typescript
import { defineConfig } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  timeout: 30000,
  use: {
    baseURL: 'http://localhost:3000',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    { name: 'chromium', use: { browserName: 'chromium' } },
  ],
})
```

**E2E test v√≠ d·ª•:**
```typescript
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Authentication', () => {
  test('should login successfully with valid credentials', async ({ page }) => {
    await page.goto('/admin/login')

    await page.fill('input[type="email"]', 'admin@iconiclogs.com')
    await page.fill('input[type="password"]', 'admin123')
    await page.click('button[type="submit"]')

    await expect(page).toHaveURL('/admin/dashboard')
    await expect(page.locator('text=Dashboard')).toBeVisible()
  })

  test('should show error with invalid credentials', async ({ page }) => {
    await page.goto('/admin/login')

    await page.fill('input[type="email"]', 'admin@iconiclogs.com')
    await page.fill('input[type="password"]', 'wrongpassword')
    await page.click('button[type="submit"]')

    await expect(page.locator('text=Invalid credentials')).toBeVisible()
  })

  test('should logout successfully', async ({ page }) => {
    // Login first
    await page.goto('/admin/login')
    await page.fill('input[type="email"]', 'admin@iconiclogs.com')
    await page.fill('input[type="password"]', 'admin123')
    await page.click('button[type="submit"]')

    // Logout
    await page.click('button:has-text("Logout")')
    await expect(page).toHaveURL('/admin/login')
  })
})
```

**Checklist:**
- [ ] Install Jest & dependencies
- [ ] Create jest.config.js
- [ ] Write tests cho `src/lib/auth.ts`
- [ ] Write tests cho `src/lib/permissions.ts`
- [ ] Write tests cho `src/lib/utils.ts`
- [ ] Install Playwright
- [ ] Create playwright.config.ts
- [ ] Write E2E tests cho login flow
- [ ] Write E2E tests cho CRUD posts
- [ ] Write E2E tests cho user management
- [ ] Add test scripts v√†o package.json
- [ ] Setup CI/CD ƒë·ªÉ ch·∫°y tests
- [ ] Target: 70% code coverage

**Update package.json:**
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

---

## üü° MEDIUM PRIORITY (Sau Launch - 1-2 th√°ng)

### ‚úÖ TASK 7: File Upload Security Hardening
**M·ª©c ƒë·ªô:** üü° MEDIUM
**File:** `src/app/api/media/upload/route.ts`
**∆Ø·ªõc t√≠nh:** 3-4 gi·ªù

**V·∫•n ƒë·ªÅ:**
- Ch·ªâ check MIME type (d·ªÖ bypass)
- Kh√¥ng check magic bytes
- Kh√¥ng scan virus
- Kh√¥ng compress images
- Filename c√≥ th·ªÉ duplicate

**C·∫ßn l√†m:**
```bash
npm install file-type sharp uuid
```

```typescript
import { fileTypeFromBuffer } from 'file-type'
import sharp from 'sharp'
import { v4 as uuidv4 } from 'uuid'

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 })
    }

    const bytes = await file.arrayBuffer()
    const buffer = Buffer.from(bytes)

    // 1. Check magic bytes (real file type)
    const fileType = await fileTypeFromBuffer(buffer)
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp']

    if (!fileType || !allowedTypes.includes(fileType.mime)) {
      return NextResponse.json(
        { error: 'Invalid file type. Only images are allowed.' },
        { status: 400 }
      )
    }

    // 2. Validate file size (max 5MB)
    const maxSize = 5 * 1024 * 1024
    if (buffer.length > maxSize) {
      return NextResponse.json(
        { error: 'File too large. Maximum size is 5MB.' },
        { status: 400 }
      )
    }

    // 3. Optimize & resize image with sharp
    const optimizedBuffer = await sharp(buffer)
      .resize(2000, 2000, { fit: 'inside', withoutEnlargement: true })
      .jpeg({ quality: 85 })
      .toBuffer()

    // 4. Generate unique filename with UUID
    const uniqueFilename = `${uuidv4()}.${fileType.ext}`
    const uploadsDir = path.join(process.cwd(), 'public', 'uploads')

    if (!existsSync(uploadsDir)) {
      await mkdir(uploadsDir, { recursive: true })
    }

    const filepath = path.join(uploadsDir, uniqueFilename)
    await writeFile(filepath, optimizedBuffer)

    // 5. Get image dimensions
    const metadata = await sharp(optimizedBuffer).metadata()

    // 6. Create media record
    const media = await prisma.media.create({
      data: {
        filename: file.name,
        url: `/uploads/${uniqueFilename}`,
        mimeType: fileType.mime,
        size: optimizedBuffer.length,
        width: metadata.width,
        height: metadata.height,
      },
    })

    return NextResponse.json({ success: true, media })
  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: 'Failed to upload file' },
      { status: 500 }
    )
  }
}
```

**Checklist:**
- [ ] Install dependencies (file-type, sharp, uuid)
- [ ] Add magic bytes validation
- [ ] Add image optimization v·ªõi sharp
- [ ] Generate unique filenames v·ªõi UUID
- [ ] Add image dimensions v√†o database
- [ ] Add upload quota per user (optional)
- [ ] Consider virus scanning (ClamAV/VirusTotal)
- [ ] Test v·ªõi fake MIME types
- [ ] Test v·ªõi large files
- [ ] Test v·ªõi malicious files

---

### ‚úÖ TASK 8: Add Pagination cho Large Datasets
**M·ª©c ƒë·ªô:** üü° MEDIUM
**Files:** Multiple API routes
**∆Ø·ªõc t√≠nh:** 2-3 gi·ªù

**V·∫•n ƒë·ªÅ:**
- `GET /api/admin/posts` fetch ALL posts
- `GET /api/admin/users` fetch ALL users
- Khi c√≥ 10,000 records ‚Üí slow & memory issues

**C·∫ßn l√†m:**
```typescript
// src/lib/pagination.ts
import { z } from 'zod'

export const PaginationSchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
  sortBy: z.string().optional(),
  order: z.enum(['asc', 'desc']).default('desc'),
})

export function getPaginationParams(searchParams: URLSearchParams) {
  const params = {
    page: searchParams.get('page'),
    limit: searchParams.get('limit'),
    sortBy: searchParams.get('sortBy'),
    order: searchParams.get('order'),
  }

  return PaginationSchema.parse(params)
}

export function createPaginationResponse<T>(
  data: T[],
  total: number,
  page: number,
  limit: number
) {
  const totalPages = Math.ceil(total / limit)

  return {
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasMore: page < totalPages,
    },
  }
}
```

**Update API routes:**
```typescript
// src/app/api/admin/posts/route.ts
export async function GET(request: NextRequest) {
  try {
    const user = await requireAuth()
    const { searchParams } = new URL(request.url)
    const { page, limit, order } = getPaginationParams(searchParams)

    const skip = (page - 1) * limit

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        skip,
        take: limit,
        include: { createdBy: true },
        orderBy: { updatedAt: order },
      }),
      prisma.post.count(),
    ])

    return NextResponse.json(
      createPaginationResponse(posts, total, page, limit)
    )
  } catch (error) {
    return handleApiError(error, 'GET /api/admin/posts')
  }
}
```

**Checklist:**
- [ ] T·∫°o `src/lib/pagination.ts`
- [ ] Update `GET /api/admin/posts`
- [ ] Update `GET /api/admin/users`
- [ ] Update `GET /api/media`
- [ ] Add search/filter support
- [ ] Update frontend ƒë·ªÉ hi·ªÉn th·ªã pagination
- [ ] Add loading states
- [ ] Test v·ªõi large datasets

---

### ‚úÖ TASK 9: Standardize Auth Functions
**M·ª©c ƒë·ªô:** üü° MEDIUM
**File:** `src/lib/auth.ts`
**∆Ø·ªõc t√≠nh:** 1-2 gi·ªù

**V·∫•n ƒë·ªÅ:**
- C√≥ 3 h√†m t∆∞∆°ng t·ª±: `getCurrentUser()`, `requireAuth()`, `verifyAuth()`
- G√¢y confusion cho developers
- M·ªôt s·ªë routes d√πng getCurrentUser, m·ªôt s·ªë d√πng verifyAuth

**C·∫ßn l√†m:**
1. Refactor th√†nh 2 functions r√µ r√†ng:
```typescript
// src/lib/auth.ts

// For Server Components (uses cookies())
export async function getCurrentUser() {
  const token = await getAuthToken()
  if (!token) return null

  const payload = verifyToken(token)
  if (!payload) return null

  const user = await prisma.user.findUnique({
    where: { id: payload.userId, active: true },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
    },
  })

  return user
}

// For API Routes (throws if not authenticated)
export async function requireAuth() {
  const user = await getCurrentUser()
  if (!user) {
    throw new Error('Unauthorized')
  }
  return user
}

// DEPRECATED: Use requireAuth() instead
export async function verifyAuth(request: Request) {
  console.warn('verifyAuth() is deprecated. Use requireAuth() instead.')
  return requireAuth()
}
```

2. Update t·∫•t c·∫£ API routes ƒë·ªÉ d√πng `requireAuth()`:
```typescript
// Before
const user = await verifyAuth(request)
if (!user) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
}

// After
try {
  const user = await requireAuth()
  // ... rest of code
} catch (error) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
}
```

**Checklist:**
- [ ] Refactor `src/lib/auth.ts`
- [ ] Mark `verifyAuth()` as deprecated
- [ ] Update `/api/admin/posts/route.ts`
- [ ] Update `/api/admin/users/route.ts`
- [ ] Update `/api/admin/users/[id]/route.ts`
- [ ] Update documentation
- [ ] Add JSDoc comments
- [ ] Write tests cho auth functions

---

### ‚úÖ TASK 10: Implement Audit Logging
**M·ª©c ƒë·ªô:** üü° MEDIUM
**Files:** New model + API routes
**∆Ø·ªõc t√≠nh:** 4-5 gi·ªù

**V·∫•n ƒë·ªÅ:**
- Kh√¥ng track admin actions
- Kh√¥ng bi·∫øt ai l√†m g√¨, khi n√†o
- Kh√≥ debug issues
- Compliance issues

**C·∫ßn l√†m:**

#### 1. Add AuditLog model:
```prisma
// prisma/schema.prisma
model AuditLog {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  action     String   // CREATE, UPDATE, DELETE, LOGIN, LOGOUT
  resource   String   // USER, POST, SERVICE, MEDIA, etc.
  resourceId String?  @map("resource_id")
  changes    Json?    // Before/after values
  ipAddress  String?  @map("ip_address")
  userAgent  String?  @map("user_agent")
  createdAt  DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([resource, resourceId])
  @@index([createdAt])
  @@map("audit_logs")
}

// Update User model
model User {
  // ... existing fields
  auditLogs AuditLog[]
}
```

#### 2. Create audit logger utility:
```typescript
// src/lib/audit-logger.ts
import { prisma } from './db'

interface AuditLogData {
  userId: string
  action: 'CREATE' | 'UPDATE' | 'DELETE' | 'LOGIN' | 'LOGOUT'
  resource: 'USER' | 'POST' | 'SERVICE' | 'MEDIA' | 'COMPANY_INFO'
  resourceId?: string
  changes?: {
    before?: Record<string, any>
    after?: Record<string, any>
  }
  ipAddress?: string
  userAgent?: string
}

export async function logAudit(data: AuditLogData) {
  try {
    await prisma.auditLog.create({
      data: {
        userId: data.userId,
        action: data.action,
        resource: data.resource,
        resourceId: data.resourceId,
        changes: data.changes,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent,
      },
    })
  } catch (error) {
    console.error('Failed to log audit:', error)
    // Don't throw - audit logging should not break main flow
  }
}

export function getClientInfo(request: Request) {
  const ipAddress =
    request.headers.get('x-forwarded-for')?.split(',')[0] ||
    request.headers.get('x-real-ip') ||
    'unknown'

  const userAgent = request.headers.get('user-agent') || 'unknown'

  return { ipAddress, userAgent }
}
```

#### 3. Use trong API routes:
```typescript
// Example: src/app/api/admin/posts/[id]/route.ts
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await requireAuth()
    const postId = params.id

    // Get old post data for audit log
    const oldPost = await prisma.post.findUnique({
      where: { id: postId },
    })

    if (!oldPost) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 })
    }

    // Delete post
    await prisma.post.delete({
      where: { id: postId },
    })

    // Log audit
    const { ipAddress, userAgent } = getClientInfo(request)
    await logAudit({
      userId: user.id,
      action: 'DELETE',
      resource: 'POST',
      resourceId: postId,
      changes: { before: oldPost },
      ipAddress,
      userAgent,
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    return handleApiError(error, 'DELETE /api/admin/posts/[id]')
  }
}
```

**Checklist:**
- [ ] Add AuditLog model v√†o schema.prisma
- [ ] Run migration: `npx prisma migrate dev`
- [ ] Create `src/lib/audit-logger.ts`
- [ ] Add audit logging cho login/logout
- [ ] Add audit logging cho user CRUD
- [ ] Add audit logging cho post CRUD
- [ ] Add audit logging cho media upload/delete
- [ ] Create admin page ƒë·ªÉ xem audit logs
- [ ] Add filtering by user, action, resource
- [ ] Add export audit logs to CSV
- [ ] Test audit logging

---

### ‚úÖ TASK 11: Add Database Indexes
**M·ª©c ƒë·ªô:** üü° MEDIUM
**File:** `prisma/schema.prisma`
**∆Ø·ªõc t√≠nh:** 1 gi·ªù

**V·∫•n ƒë·ªÅ:**
- User.email kh√¥ng c√≥ index ‚Üí slow login
- User.role kh√¥ng c√≥ index ‚Üí slow permission checks
- C√°c queries th∆∞·ªùng xuy√™n kh√¥ng ƒë∆∞·ª£c optimize

**C·∫ßn l√†m:**
```prisma
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String   @map("password_hash")
  role         Role     @default(ADMIN)
  active       Boolean  @default(true)
  lastLoginAt  DateTime? @map("last_login_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  posts        Post[]

  @@index([email])
  @@index([role])
  @@index([active, lastLoginAt])
  @@map("users")
}

model Post {
  // ... existing fields

  @@index([status, publishedAt])
  @@index([slug])
  @@index([createdById])
  @@index([createdAt])
  @@map("posts")
}

model Media {
  // ... existing fields

  @@index([mimeType])
  @@index([createdAt])
  @@map("media")
}

model ContactForm {
  // ... existing fields

  @@index([email])
  @@index([createdAt])
  @@map("contact_forms")
}
```

**Checklist:**
- [ ] Add indexes v√†o schema.prisma
- [ ] Run migration: `npx prisma migrate dev --name add_indexes`
- [ ] Test query performance
- [ ] Monitor index usage v·ªõi `EXPLAIN ANALYZE`
- [ ] Document index strategy

---

### ‚úÖ TASK 12: Add Internationalization (i18n)
**M·ª©c ƒë·ªô:** üü° MEDIUM
**Files:** Multiple files
**∆Ø·ªõc t√≠nh:** 1-2 ng√†y

**V·∫•n ƒë·ªÅ:**
- UI labels hardcoded b·∫±ng ti·∫øng Vi·ªát
- Kh√¥ng support ƒëa ng√¥n ng·ªØ
- Mix Vietnamese trong code

**C·∫ßn l√†m:**
```bash
npm install next-intl
```

**Setup:**
```typescript
// i18n/request.ts
import { getRequestConfig } from 'next-intl/server'

export default getRequestConfig(async ({ locale }) => ({
  messages: (await import(`./messages/${locale}.json`)).default,
}))
```

**Translation files:**
```json
// i18n/messages/vi.json
{
  "common": {
    "welcome": "Ch√†o m·ª´ng",
    "login": "ƒêƒÉng nh·∫≠p",
    "logout": "ƒêƒÉng xu·∫•t",
    "email": "Email",
    "password": "M·∫≠t kh·∫©u"
  },
  "errors": {
    "invalidCredentials": "Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng",
    "accountDisabled": "T√†i kho·∫£n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a"
  }
}

// i18n/messages/en.json
{
  "common": {
    "welcome": "Welcome",
    "login": "Login",
    "logout": "Logout",
    "email": "Email",
    "password": "Password"
  },
  "errors": {
    "invalidCredentials": "Invalid email or password",
    "accountDisabled": "Account has been disabled"
  }
}
```

**Usage:**
```typescript
import { useTranslations } from 'next-intl'

export default function LoginPage() {
  const t = useTranslations('common')

  return (
    <div>
      <h1>{t('welcome')}</h1>
      <button>{t('login')}</button>
    </div>
  )
}
```

**Checklist:**
- [ ] Install next-intl
- [ ] Create translation structure
- [ ] Extract Vietnamese strings
- [ ] Create English translations
- [ ] Update all components
- [ ] Add language switcher
- [ ] Update API error messages
- [ ] Test language switching
- [ ] Update documentation

---

## üü¢ LOW PRIORITY (Nice to Have - 3-6 th√°ng)

### ‚úÖ TASK 13: Extend ESLint Configuration
**M·ª©c ƒë·ªô:** üü¢ LOW
**File:** `.eslintrc.json`
**∆Ø·ªõc t√≠nh:** 1-2 gi·ªù

**C·∫ßn l√†m:**
```bash
npm install -D @typescript-eslint/eslint-plugin eslint-plugin-security eslint-plugin-import
```

```json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "plugin:security/recommended"
  ],
  "plugins": ["@typescript-eslint", "security", "import"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "import/order": ["error", {
      "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
      "newlines-between": "always",
      "alphabetize": { "order": "asc" }
    }],
    "security/detect-object-injection": "off",
    "security/detect-non-literal-fs-filename": "off"
  }
}
```

**Checklist:**
- [ ] Install ESLint plugins
- [ ] Update .eslintrc.json
- [ ] Fix existing linting errors
- [ ] Add pre-commit hook v·ªõi husky
- [ ] Update CI/CD ƒë·ªÉ check linting

---

### ‚úÖ TASK 14: Image Optimization Pipeline
**M·ª©c ƒë·ªô:** üü¢ LOW
**File:** `src/app/api/media/upload/route.ts`
**∆Ø·ªõc t√≠nh:** 2-3 gi·ªù

**C·∫ßn l√†m:**
- [x] Already covered in TASK 7 v·ªõi sharp
- [ ] Add thumbnail generation
- [ ] Add WebP conversion
- [ ] Add lazy loading support
- [ ] Add CDN integration (Cloudflare/CloudFront)

---

### ‚úÖ TASK 15: Implement Caching Strategy
**M·ª©c ƒë·ªô:** üü¢ LOW
**Files:** Multiple
**∆Ø·ªõc t√≠nh:** 1-2 ng√†y

**C·∫ßn l√†m:**
```bash
npm install ioredis
```

**Redis caching:**
```typescript
// src/lib/cache.ts
import Redis from 'ioredis'

const redis = new Redis(process.env.REDIS_URL)

export async function getCached<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = 3600
): Promise<T> {
  const cached = await redis.get(key)

  if (cached) {
    return JSON.parse(cached)
  }

  const data = await fetcher()
  await redis.setex(key, ttl, JSON.stringify(data))

  return data
}

export async function invalidateCache(pattern: string) {
  const keys = await redis.keys(pattern)
  if (keys.length > 0) {
    await redis.del(...keys)
  }
}
```

**Usage:**
```typescript
// Cache published posts for 5 minutes
const posts = await getCached(
  'posts:published',
  async () => {
    return await prisma.post.findMany({
      where: { status: 'PUBLISHED' },
      orderBy: { publishedAt: 'desc' },
    })
  },
  300
)
```

**Checklist:**
- [ ] Setup Redis (local/cloud)
- [ ] Create cache utility
- [ ] Add caching cho public posts
- [ ] Add caching cho services
- [ ] Add caching cho company info
- [ ] Invalidate cache on updates
- [ ] Add cache headers cho static assets
- [ ] Setup CDN (optional)

---

### ‚úÖ TASK 16: TypeScript Strict Configuration
**M·ª©c ƒë·ªô:** üü¢ LOW
**File:** `tsconfig.json`
**∆Ø·ªõc t√≠nh:** 2-3 gi·ªù

**C·∫ßn l√†m:**
```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

**Checklist:**
- [ ] Enable strict checks
- [ ] Fix type errors
- [ ] Add proper type definitions
- [ ] Remove `any` types

---

### ‚úÖ TASK 17: Add Error Boundaries
**M·ª©c ƒë·ªô:** üü¢ LOW
**Files:** New components
**∆Ø·ªõc t√≠nh:** 2 gi·ªù

**C·∫ßn l√†m:**
```typescript
// src/components/ErrorBoundary.tsx
'use client'

import { Component, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('ErrorBoundary caught:', error, errorInfo)
    // Send to error monitoring service
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 bg-red-50 border border-red-200 rounded">
          <h2 className="text-red-800 font-bold">C√≥ l·ªói x·∫£y ra</h2>
          <p className="text-red-600">Vui l√≤ng t·∫£i l·∫°i trang</p>
        </div>
      )
    }

    return this.props.children
  }
}
```

**Usage:**
```typescript
<ErrorBoundary>
  <AdminPostsPage />
</ErrorBoundary>
```

---

### ‚úÖ TASK 18: Environment Variables Validation
**M·ª©c ƒë·ªô:** üü¢ LOW
**Files:** New file
**∆Ø·ªõc t√≠nh:** 1 gi·ªù

**C·∫ßn l√†m:**
```typescript
// src/lib/validate-env.ts
import { z } from 'zod'

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  DATABASE_URL: z.string().url(),
  DIRECT_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  SITE_URL: z.string().url(),
  N8N_WEBHOOK_URL: z.string().url().optional(),
  N8N_API_KEY: z.string().optional(),
  REDIS_URL: z.string().url().optional(),
})

export function validateEnv() {
  try {
    envSchema.parse(process.env)
  } catch (error) {
    console.error('‚ùå Invalid environment variables:', error)
    process.exit(1)
  }
}
```

```typescript
// src/app/layout.tsx
import { validateEnv } from '@/lib/validate-env'

if (process.env.NODE_ENV !== 'development') {
  validateEnv()
}
```

---

## üìà PROGRESS TRACKING

### Sprint 1 (Week 1-2): Critical Security Fixes
- [ ] TASK 1: JWT_SECRET validation
- [ ] TASK 2: Rate limiting
- [ ] TASK 3: Environment variables
- [ ] TASK 4: Generic errors
- [ ] TASK 5: Zod validation
- [ ] TASK 6: Testing setup

**Target:** Ho√†n th√†nh 100% critical security issues

### Sprint 2 (Week 3-4): Testing & Documentation
- [ ] Write 50+ unit tests
- [ ] Write 20+ E2E tests
- [ ] Achieve 70% code coverage
- [ ] Update documentation

**Target:** 70% test coverage

### Sprint 3 (Month 2): Medium Priority
- [ ] TASK 7: File upload security
- [ ] TASK 8: Pagination
- [ ] TASK 9: Auth standardization
- [ ] TASK 10: Audit logging
- [ ] TASK 11: Database indexes
- [ ] TASK 12: i18n (optional)

**Target:** Production-ready v·ªõi full security

### Sprint 4 (Month 3-6): Optimization
- [ ] TASK 13-18: Low priority tasks
- [ ] Performance optimization
- [ ] Caching strategy
- [ ] Monitoring & alerting

**Target:** Optimized & scalable

---

## üéØ SUCCESS METRICS

### Security
- ‚úÖ No hardcoded secrets
- ‚úÖ Rate limiting active
- ‚úÖ Input validation v·ªõi Zod
- ‚úÖ Generic error messages
- ‚úÖ Audit logging enabled

### Testing
- ‚úÖ 70%+ code coverage
- ‚úÖ All critical flows tested
- ‚úÖ CI/CD running tests
- ‚úÖ No regression bugs

### Performance
- ‚úÖ API response < 200ms (p95)
- ‚úÖ Page load < 2s
- ‚úÖ Lighthouse score > 90
- ‚úÖ Zero N+1 queries

### Developer Experience
- ‚úÖ TypeScript strict mode
- ‚úÖ ESLint configured
- ‚úÖ Pre-commit hooks
- ‚úÖ Good documentation

---

## üìö REFERENCES

### Documentation
- [Next.js 15 Docs](https://nextjs.org/docs)
- [Prisma Best Practices](https://www.prisma.io/docs/guides/performance-and-optimization)
- [Zod Validation](https://zod.dev/)
- [Jest Testing](https://jestjs.io/docs/getting-started)
- [Playwright E2E](https://playwright.dev/)

### Security
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Next.js Security](https://nextjs.org/docs/advanced-features/security-headers)
- [JWT Best Practices](https://tools.ietf.org/html/rfc8725)

### Tools
- [Upstash Redis](https://upstash.com/)
- [Sentry Error Monitoring](https://sentry.io/)
- [Sharp Image Processing](https://sharp.pixelplumbing.com/)

---

## ‚úÖ CHECKLIST T·ªîNG

### Phase 1: Critical (Tr∆∞·ªõc Production)
- [ ] JWT_SECRET validation
- [ ] Rate limiting cho login
- [ ] Move URLs sang env vars
- [ ] Generic error messages
- [ ] Zod validation
- [ ] Testing framework setup

### Phase 2: Security Hardening
- [ ] File upload security
- [ ] Audit logging
- [ ] Database indexes
- [ ] Auth standardization

### Phase 3: Optimization
- [ ] Pagination
- [ ] Caching v·ªõi Redis
- [ ] Image optimization
- [ ] i18n support

### Phase 4: DevEx & Quality
- [ ] ESLint extended
- [ ] TypeScript strict
- [ ] Error boundaries
- [ ] Env validation

---

**Ng√†y c·∫≠p nh·∫≠t cu·ªëi:** 05/11/2025
**Version:** 1.0
**Ng∆∞·ªùi review:** Claude Code (AI Assistant)
